Регулярные выражения - очень мощный, но довольно тупой набор инструментов для поиска определенных слов или комбинаций символов в строках.

Зачем нужны регулярные выражения?

Зачем вообще возиться с регулярными выражениями? Чем они могут помочь именно вам?

Сравнение с шаблоном: 
Регулярные выражения отлично помогают определять, соответствует ли строка тому или иному формату – например, телефонному номеру, адресу электронной почты или номеру кредитной карты.

Замена: При помощи регулярных выражений легко находить и заменять шаблоны в строке. Так, выражение text.replace(/\s+/g, " ") заменяет все пробелы в text, например, " \n\t ", одним пробелом.

Извлечение: При помощи регулярных выражений легко извлекать из шаблона фрагменты информации. Например, name.matches(/^(Mr|Ms|Mrs|Dr)\.?\s/i)[1] извлекает из строки обращение к человеку, например, "Mr" из "Mr. Schropp".

Портируемость: Почти в любом распространенном языке программирования есть своя библиотека регулярных выражений. Синтаксис в основном стандартизирован, поэтому вам не придется переучиваться регулярным выражениям при переходе на новый язык.

Код: Когда пишете код, можно пользоваться регулярными выражениями для поиска информации в файлах; так, в Atom для этого предусмотрен find and replace, а в командной строке — ack.

Четкость и лаконичность: Если вы с регулярными выражениями на «ты», то сможете выполнять весьма нетривиальные операции, написав минимальный объем кода.

Валидация данных (например, правильно ли заполнена строка time)

Сбор данных (особенно веб-скрапинг, поиск страниц, содержащих определённый набор слов в определённом порядке)

Обработка данных (преобразование сырых данных в нужный формат)

Парсинг (например, достать все GET параметры из URL или текст внутри скобок)

Замена строк (даже во время написания кода в IDE, можно, например преобразовать Java или C# класс в соответствующий JSON объект, заменить “;” на “,”, изменить размер букв, избегать объявление типа и т.д.)

Подсветка синтаксиса, переименование файла, анализ пакетов и многие другие задачи, где нужно работать со строками (где данные не должны быть текстовыми).

Выражение	Символ
"\d"	соответствует одному символу, который является цифрой
"\D"	соответствует одному символу, который не является цифрой
"\s"	соответствует символу пробела (включая табуляцию и прерывание строки)
"\S"	все, кроме пробельных символов
"\w"	соответствует слову (может состоять из букв, цифр и подчёркивания)
"\W"	все кроме букв
"\b"	граница слова
"\B"	не граница слова
"."     соответствует любому символу

// кванторы
С помощью кванторов мы можем описать, например строку, содержащую номер банковской карты: /\d{4}[\s\-]?\d{4}[\s\-]?\d{4}[\s\-]?\d{4}/

"*"	    0 или более раз
"+"	    1 или более раз
"?"	    0 или 1 раз
"{n}"	точно n раз
"{n,m}"	от n до m раз

// Флаги
g (global) ― не возвращает результат после первого совпадения, а продолжает поиск с конца предыдущего совпадения.
m (multi line) ― включает многострочный режим. В этом режиме ^ и $ совпадают с началом и концом всей строки. Без этого флага, с многострочными строками они совпадают с началом и концом каждой строки.
i (insensitive) ― делает выражение регистронезависимым (например, /aBc/i соответствует AbC).
u ―  включает поддержку Unicode (добавлено в ES6/ES2015)
s ― (новое в ES2018) сокращение от "single line", он позволяет . совпадать с символами новой строки

// Якоря — ^ и $
^Привет        соответствует строке, начинающейся с Привет -> тест
пока$          соответствует строке, заканчивающейся на пока
^Привет пока$  точное совпадение (начинается и заканчивается как Привет пока)
воробушки      соответствует любой строке, в которой есть текст воробушки

//Скобочные группы ― ()
a(bc)       создаём группу со значением bc
a(?:bc)*    оперетор ?: отключает группу
a(?<foo>bc) так, мы можем присвоить имя группе
!Этот оператор очень полезен, когда нужно извлечь информацию из строк или данных, используя ваш любимый язык программирования. Любые множественные совпадения, по нескольким группам, будут представлены в виде классического массива: доступ к их значениям можно получить с помощью индекса из результатов сопоставления.

//Скобочные выражения ― []
[abc]       соответствует строке, которая содержит либо символ a или a b или a c 
            -> такой же эффект от a|b|c
[a-c]       то же, что и выше
[a-fA-F0–9] строка, представляющая одну шестнадцатеричную цифру без учёта регистра
[0–9]%      строка, содержащая символ от 0 до 9 перед знаком %
[^a-zA-Z]   строка, которая не имеет буквы от a до z или от A до Z. В этом случае ^              используется как отрицание в выражении 
!Помните, что внутри скобочных выражений все специальные символы (включая обратную косую черту \) теряют своё служебное значение, поэтому нам ненужно их экранировать.

//Жадные и ленивые сопоставления
Квантификаторы ( * + {}) ― это «жадные» операторы, потому что они продолжают поиск      соответствий, как можно глубже ― через весь текст.
   Пример: <.+> соответствует <div>simple div</div>
    Чтобы найти только тэг div ― можно использовать оператор ?, сделав выражение ленивым»:

    <.+?> соответствует любому символу, один или несколько раз найденному между < и >, расширяется по мере необходимости

    <[^<>]+> соответствует любому символу, кроме < или >, один или более раз встречающемуся между < и >

    console.log(/\$(.+)\s?/.exec('This costs $100 and it is less than $200')[1]);
    //100 and it is less than $200

    Почему? Потому что регулярное выражение после знака $ совпадает с любым символом .+ и не останавливается пока не достигнет конца строки. Затем он останавливается,потому что \s? делает конечное пространство необязательным.

    console.log(/\$(.+?)\s/.exec('This costs $100 and it is less than $200')[1]);
    //100

//Границы слов ― \b и \B
\b и \B позволяют определить находится ли строка в начале или конце слова:

\b совпадает если набор символов находится в начале или конце слова
\B совпадает если набор символов не находится в начале или конце слова
Пример:

'I saw a bear'.match(/\bbear/)    //Array ["bear"]
'I saw a beard'.match(/\bbear/)   //Array ["bear"]
'I saw a beard'.match(/\bbear\b/) //null
'cool_bear'.match(/\bbear\b/)     //null

Замена с помощью регулярных выражений
У объекта String в JavaScript есть метод replace(), который можно использовать без регулярных выражений для одной замены в строке:

"Hello world!".replace('world', 'dog') //Hello dog!
"My dog is a good dog!".replace('dog', 'cat') //My cat is a good dog!

"Hello world!".replace(/world/, 'dog') //Hello dog!

Использование флага g - это единственный способ заменить несколько вхождений в строке
"My dog is a good dog!".replace(/dog/g, 'cat') //My cat is a good cat!

"Hello, world!".replace(/(\w+), (\w+)!/, '$2: $1!!!')
// "world: Hello!!!"

"Hello, world!".replace(/(\w+), (\w+)!/, (matchedString, first, second) => {
  console.log(first);
  console.log(second);

  return `${second.toUpperCase()}: ${first}!!!`
})
//"WORLD: Hello!!!"
